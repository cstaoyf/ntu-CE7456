\include{./def/yf-formatting}
\include{./def/yf-def}

\title{}
\author{}
\date{}



\def\bD{\mathbb{D}}
\def\bQ{\mathbb{Q}}

\def\A{\mathcal{A}}
\def\B{\mathcal{B}}
\def\C{\mathcal{C}}
\def\D{\mathcal{D}}
\def\E{\mathcal{E}}
\def\F{\mathcal{F}}
\def\G{\mathcal{G}}
\def\I{\mathcal{I}}
\def\L{\mathcal{L}}
\def\R{\mathcal{R}}
\def\T{\mathcal{T}}
%\def\U{\mathcal{U}}
%\def\X{\mathcal{X}}
\def\ans{\rank{rank}}

\def\extraspacing{\vspace{3mm} \noindent}
\def\vgap{\vspace{3mm}}
\def\vslit{\vspace{0.5mm}}

\DeclareMathOperator*{\Log}{Log}

\begin{document}

% \begin{center}
%     {\bf \large Lecture Notes} \\
%     {\bf \large Approximate Nearest Neighbor Search 1 : Proximity Graphs} \\[5mm]
%     {\large Yufei Tao} \\[10mm]
% \end{center}

\boxminipg{\linewidth}{
    \begin{center}
        \vspace{3mm}
    {\Large
    (CE7456 Lecture Notes 8) Distribution-Aware Data Structuring} \\[1mm]
    {\Large (a.k.a.\ Learned Indexes)} \\[2mm]
    {\large Yufei Tao}
    \vspace{3mm}
    \end{center}
}


Traditional indexing first creates an index on the whole dataset before starting to answer queries. For example, after building a binary search tree (BST) on an (unsorted) set $S$ of $n$ integers in $O(n \log n)$ time, we can use the tree to answer each predecessor query\footnote{Given a search value $q$, a predecessor query returns the largest element in $S$ that does not exceed $q$.} in $O(\log n)$ time. This paradigm, however, falls short when the dataset $S$ will only be searched a small number of times. In the extreme, if only one query needs to be answered, the best approach is to scan $S$ in full, which requires only $O(n)$ time.

\section{Analysis} \label{sec:analysis}

Define
\myeqn{
    \Delta_S(q) &=& |rank_S(q) - \hat{r}_S(q)|. \nn
}
Partition the data domain $[0, U]$ into $n$ intervals of equal length; specifically, for each $j \in [n]$, the $j$-th interval is
\myeqn{
    J_j &=& [(j-1)/n, j/n]. \label{eqn:analysis-J-j}
}
Set
\myeqn{
    m_j &=& |S \cap J_j|. \label{eqn:analysis-m-j}
}
\todo{comparison remark}

The core of our analysis is to prove:

\begin{lemma} \label{lmm:anayslis-core}
    $\expt_{Q, S} [\Delta_S(Q)] = O(n) \cdot \sum_{j=1}^n p_j^2$ where $p_j = \Pr_{X \sim \D} [X \in J_j]$ for each $j \in [n]$.
\end{lemma}

\extraspacing {\bf Proof of Lemma~\ref{lmm:anayslis-core}.} By the total law of expectation, we have:
\myeqn{
    \expt_{Q, S}[\Delta_S(Q)] &=& \expt_S \Big[\expt_{Q \mid S} \Big[\Delta_S(Q) | S \Big] \Big] \nn  \\
    \explain{by independence of $Q$ and $S$} &=& \expt_S \Big[\expt_{Q} \Big[\Delta_S(Q) | S \Big] \Big].
    \label{eqn:analysis-core-h1}
}
The subsequent discussion will focus on $\expt_Q [\Delta_S(Q) | S]$, for which we have:
\myeqn{
    \expt_Q [\Delta_S(Q) | S]
    &=&
    \int_0^U \Delta_S(q) \cdot f(q) dq \nn \\
    &=&
    \sum_{i=1}^n \int_{I_i} \Delta_S(q) \cdot f(q) dq \nn \\
    \explain{\todo{reason}}
    &\le&
    \sum_{i=1}^n \fr{n_i}{2} \int_{I_i} f(q) dq \label{eqn:analysis-core-h2}
}
where --- let us recall --- $n_i = |S \cap I_i|$. Define for each $i, j \in [n]$:
\myeqn{
    n_{i,j} = |S \cap I_i \cap J_j|. \label{eqn:analysis-n-ij} \nn
}
Thus
\myeqn{
    \eqref{eqn:analysis-core-h2} =
    \fr{1}{2} \sum_{i=1}^n \sum_{j=1}^n n_{i,j} \int_{I_i} f(q) dq
    =
    \fr{1}{2} \sum_{j=1}^n \sum_{i=1}^n n_{i,j} \int_{I_i} f(q) dq.
    \label{eqn:analysis-core-h3}
}
For a specific $j \in [n]$, we have
\myeqn{
    \sum_{i=1}^n n_{i,j} \int_{I_i} f(q) dq
    &=&
    \sum_{i \in [n]: I_i \cap J_j \ne \emptyset} n_{i,j} \int_{I_i} f(q) dq \nn \\
    \explain{\todo{}}
    &\le&
    \sum_{i \in [n]: I_i \cap J_j \ne \emptyset} n_{i,j} \int_{I_i} f(q) dq \nn \\
}

\bibliographystyle{plain}
\bibliography{ref}

\end{document}
